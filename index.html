<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect width='100' height='100' fill='%23edece7' rx='16'/><text x='50%' y='47%' dominant-baseline='central' text-anchor='middle' font-size='85' font-family='Arial' font-weight='bold' fill='%2317140c'>ç™½</text></svg>">
    <title>Shiro</title>
    <meta name="description" content="A clean, distraction-free text editor for focused writing.">
    <script>
        // Set theme before CSS is applied to avoid screen flashing
        (function () {
            const savedTheme = localStorage.getItem('shiroTheme');
            const theme = savedTheme ||
                (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            document.documentElement.setAttribute('data-theme', theme);
        })();
    </script>
    <style>
        * {
            box-sizing: border-box;
        }

        :root {
            --bg: #17140c;
            --text: #edece7;
            --placeholder: rgb(from var(--text) r g b / 0.5);
            --transition: 0.3s ease;
            --hover-accent: #c84733;
            --caret: rgba(from var(--hover-accent) r g b / 0.9);
        }

        [data-theme="light"] {
            --bg: #edece7;
            --text: #17140c;
            --placeholder: rgb(from var(--text) r g b / 0.5);
            --caret: var(--hover-accent);
        }

        body {
            margin: 0;
            font: 18px/1.6 "Menlo", "DejaVu Sans Mono", "Consolas", monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            display: grid;
            grid-template-rows: auto 1fr auto;
            transition: background var(--transition);
            overflow: hidden;
        }

        body,
        #editor,
        .btn,
        #editor::placeholder {
            transition: background var(--transition), color var(--transition), opacity var(--transition);
        }

        #count,
        [data-action="theme"] {
            transition: opacity var(--transition), color var(--transition);
        }

        .controls {
            display: flex;
            justify-content: space-between;
            padding: 18px 20px;
            gap: 20px;
            transition: opacity var(--transition);
        }

        .controls>div {
            display: flex;
            gap: 20px;
        }

        .btn {
            cursor: pointer;
            font-size: 15px;
            transition: opacity var(--transition), color var(--transition);
            user-select: none;
            color: rgb(from var(--text) r g b / 0.6);
        }

        .btn:hover {
            color: var(--hover-accent);
        }

        .controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        main {
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            min-height: 0;
            position: relative;
        }

        #editor {
            width: 100%;
            height: min(80vh, 100%);
            padding-inline: clamp(20px, 10vw, 20vh);
            padding-block: 2.5vh;
            font: inherit;
            background: transparent;
            color: var(--text);
            border: none;
            outline: none;
            resize: none;
            tab-size: 4;
            caret-color: var(--caret);
        }

        #editor::placeholder {
            color: var(--placeholder);
        }

        ::selection {
            background-color: rgba(from var(--hover-accent) r g b / 0.5);
            color: inherit;
        }

        .scroll-fade {
            position: absolute;
            inset-inline: clamp(20px, 10vw, 20vh);
            height: 80px;
            pointer-events: none;
            transition: opacity var(--transition), background-color var(--transition);
            z-index: 1;
            background-color: var(--bg);
        }

        .scroll-fade.top {
            top: 0;
            mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 50%, transparent 100%);
        }

        .scroll-fade.bottom {
            bottom: 0;
            mask-image: linear-gradient(to top, black 50%, transparent 100%);
            -webkit-mask-image: linear-gradient(to top, black 50%, transparent 100%);
        }
    </style>
</head>

<body>
    <div class="controls" id="top">
        <div>
            <span class="btn" data-action="download">Download</span>
            <span class="btn" data-action="clear">Clear</span>
        </div>
        <div>
            <span class="btn" data-action="theme">Light</span>
            <span class="btn" data-action="fullscreen">Fullscreen</span>
        </div>
    </div>

    <main>
        <div class="scroll-fade top"></div>
        <textarea id="editor" placeholder="Start writing..."></textarea>
        <div class="scroll-fade bottom"></div>
    </main>

    <div class="controls" id="bottom">
        <div>
            <span class="btn" data-action="about">About</span>
        </div>
        <div>
            <span class="btn" id="count" data-action="count">0 words</span>
        </div>
    </div>

    <script>
        // LocalStorage keys
        const SHIRO_THEME = 'shiroTheme';
        const SHIRO_COUNT_MODE = 'shiroCountMode';
        const SHIRO_SAVED_TEXT = 'shiroSavedText';
        const SHIRO_CURSOR_POSITION = 'shiroCursorPosition';

        class Shiro {
            constructor() {
                this.editor = document.getElementById('editor');
                this.controls = document.querySelectorAll('.controls');
                this.countDisplay = document.getElementById('count');
                this.fadeTop = document.querySelector('.scroll-fade.top');
                this.fadeBottom = document.querySelector('.scroll-fade.bottom');

                this.theme = localStorage.getItem(SHIRO_THEME) ||
                    (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
                this.countMode = localStorage.getItem(SHIRO_COUNT_MODE) || 'words';
                this.segmenter = typeof Intl.Segmenter === "function"
                    ? new Intl.Segmenter(navigator.language, { granularity: "word" })
                    : null;
                this.visible = true;

                this.init();
            }

            init() {
                this.loadText();
                this.setTheme(this.theme, { transition: false });
                this.bindEvents();
                this.updateCount();
                this.editor.focus();
            }

            bindEvents() {
                // Editor events
                this.editor.addEventListener('input', () => {
                    this.saveText();
                    if (this.visible) {
                        this.updateCount();
                    }
                    this.hide();
                    this.updateFade();
                });

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
                    const modKey = isMac ? e.metaKey : e.ctrlKey;

                    if (e.key === 'Tab' && e.target === this.editor) {
                        e.preventDefault();
                        document.execCommand('insertText', false, '\t');
                        return;
                    }

                    // Open file: Ctrl+O (Windows/Linux) or Cmd+O (Mac)
                    if (modKey && e.key === 'o') {
                        e.preventDefault();
                        if (!this.editor.value.trim()) {
                            const input = document.createElement('input');
                            input.type = 'file';
                            input.accept = '.txt';
                            input.onchange = (event) => {
                                const file = event.target.files[0];
                                if (file) {
                                    const reader = new FileReader();
                                    reader.onload = () => {
                                        this.editor.value = reader.result;
                                        this.saveText();
                                        this.updateCount();
                                        this.updateFade();
                                    };
                                    reader.readAsText(file);
                                }
                                input.value = null;
                            };
                            input.click();
                        }
                        return;
                    }

                    // Save text: Ctrl+S (Windows/Linux) or Cmd+S (Mac)
                    if (modKey && e.key === 's') {
                        e.preventDefault();
                        this.download();
                        return;
                    }

                    // Clear text: Ctrl+K (Windows/Linux) or Cmd+K (Mac)
                    if (modKey && e.key === 'k') {
                        e.preventDefault();
                        this.clearWithConfirmation();
                        return;
                    }

                    // Theme toggle: Shift+Ctrl+T (Windows/Linux) or Shift+Cmd+T (Mac)
                    if (modKey && e.shiftKey && e.key === 'T') {
                        e.preventDefault();
                        this.toggleTheme();
                        return;
                    }

                    // Fullscreen toggle: Shift+Ctrl+F (Windows/Linux) or Shift+Cmd+F (Mac)
                    if (modKey && e.shiftKey && e.key === 'F') {
                        e.preventDefault();
                        this.fullscreen();
                        return;
                    }
                });

                // Use scrollend event if supported, otherwise debounce scroll event
                if ('onscrollend' in this.editor) {
                    this.editor.addEventListener('scrollend', () => this.updateFade());
                } else {
                    let scrollTimeout;
                    this.editor.addEventListener('scroll', () => {
                        clearTimeout(scrollTimeout);
                        scrollTimeout = setTimeout(() => this.updateFade(), 100);
                    });
                }

                // Always focus on editor on keydown
                window.addEventListener('keydown', () => {
                    this.editor.focus();
                });

                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => this.updateFade(), 150);
                });

                // Control buttons
                const actions = {
                    download: () => this.download(),
                    clear: () => this.clearWithConfirmation(),
                    fullscreen: () => this.fullscreen(),
                    theme: () => this.toggleTheme(),
                    about: () => this.about(),
                    count: () => this.toggleCountMode()
                };

                document.addEventListener('click', e => {
                    const action = e.target.dataset.action;
                    if (action && actions[action]) {
                        actions[action]();
                        this.editor.focus();
                    } else if (e.target !== this.editor) {
                        this.editor.focus();
                    }
                });

                // Show controls on mouse movement
                document.addEventListener('mousemove', () => this.show());

                // Fullscreen change
                document.addEventListener('fullscreenchange', () => {
                    const btn = document.querySelector('[data-action="fullscreen"]');
                    btn.textContent = document.fullscreenElement ? 'Normal' : 'Fullscreen';
                });

                // Save cursor position when it moves
                this.editor.addEventListener('selectionchange', () => {
                    this.saveCursorPosition();
                });
            }

            saveText() {
                localStorage.setItem(SHIRO_SAVED_TEXT, this.editor.value);
            }

            loadText() {
                // Hide editor until text is loaded to prevent flickering
                const editor = this.editor;
                editor.style.visibility = 'hidden';
                editor.value = localStorage.getItem(SHIRO_SAVED_TEXT) || '';
                requestAnimationFrame(() => {
                    this.loadCursorPosition();
                    editor.style.visibility = 'visible';
                    this.updateCount();
                    // Disable fade transitions until text is loaded to prevent flickering
                    this.fadeTop.style.transition = 'none';
                    this.fadeBottom.style.transition = 'none';
                    this.updateFade();
                    requestAnimationFrame(() => {
                        this.fadeTop.style.transition = '';
                        this.fadeBottom.style.transition = '';
                    });
                });
            }

            saveCursorPosition() {
                localStorage.setItem(SHIRO_CURSOR_POSITION, this.editor.selectionStart);
            }

            loadCursorPosition() {
                const saved = localStorage.getItem(SHIRO_CURSOR_POSITION);
                if (saved) {
                    const position = parseInt(saved);
                    const editor = this.editor;
                    requestAnimationFrame(() => {
                        editor.setSelectionRange(position, position);
                        editor.focus({ preventScroll: true });

                        // Fix scroll jumping when cursor is on the first line
                        const lineNumber = editor.value.substring(0, position).split('\n').length - 1;
                        if (lineNumber === 0) editor.scrollTop = 0;
                    });
                }
            }

            getWordsCount(content) {
                if (!content.trim()) return 0;

                if (this.segmenter && content.length < 300_000) {
                    let count = 0;
                    for (const segment of this.segmenter.segment(content)) {
                        if (segment.isWordLike) count++;
                    }
                    return count;
                }
                // Fallback for very old browsers or very large content
                return content.trim().split(/\s+/).filter(Boolean).length;
            }

            updateCount() {
                const text = this.editor.value;
                let count, label;

                if (this.countMode === 'words') {
                    count = this.getWordsCount(text);
                    label = `word${count !== 1 ? 's' : ''}`;
                } else {
                    count = text.length;
                    label = `character${count !== 1 ? 's' : ''}`;
                }

                this.countDisplay.textContent = `${count} ${label}`;
            }

            toggleCountMode() {
                this.countDisplay.style.opacity = '0';
                setTimeout(() => {
                    this.countMode = this.countMode === 'words' ? 'characters' : 'words';
                    localStorage.setItem(SHIRO_COUNT_MODE, this.countMode);
                    this.updateCount();
                    this.countDisplay.style.opacity = '1';
                }, 150);
            }

            hide() {
                if (this.visible) {
                    this.controls.forEach(c => c.classList.add('hidden'));
                    this.visible = false;
                }
            }

            show() {
                if (!this.visible) {
                    this.controls.forEach(c => c.classList.remove('hidden'));
                    this.visible = true;
                    this.updateCount();
                }
            }

            setTheme(theme = this.theme, { transition = true } = {}) {
                const button = document.querySelector('[data-action="theme"]');
                const apply = () => {
                    document.documentElement.setAttribute('data-theme', theme);
                    button.textContent = theme === 'dark' ? 'Light' : 'Dark';
                    localStorage.setItem(SHIRO_THEME, theme);
                    this.theme = theme;
                };

                if (transition) {
                    button.style.opacity = '0';
                    setTimeout(() => {
                        apply();
                        button.style.opacity = '1';
                    }, 150);
                } else {
                    apply();
                }
            }

            updateFade() {
                const editor = this.editor;
                const top = this.fadeTop;
                const bottom = this.fadeBottom;
                const { scrollTop, scrollHeight, clientHeight } = editor;

                top.style.opacity = scrollTop > 0 ? '1' : '0';
                bottom.style.opacity = Math.ceil(scrollTop + clientHeight) < scrollHeight ? '1' : '0';
            }

            // Actions
            download() {
                const timestamp = new Date().toISOString().slice(0, 16).replace(/[:T]/g, m => m === 'T' ? '_' : '-');
                const a = document.createElement('a');
                a.href = URL.createObjectURL(new Blob([this.editor.value], { type: 'text/plain' }));
                a.download = `shiro_${timestamp}.txt`;
                a.click();
                URL.revokeObjectURL(a.href);
            }

            clearWithConfirmation() {
                if (this.editor.value.trim() && !confirm('Are you sure you want to clear all text?')) return;
                this.clear();
            }

            clear() {
                this.editor.style.opacity = '0';
                setTimeout(() => {
                    this.editor.value = '';
                    this.editor.style.opacity = '1';
                    localStorage.removeItem(SHIRO_SAVED_TEXT);
                    this.updateCount();
                    this.updateFade();
                }, 300);
            }

            fullscreen() {
                document.fullscreenElement
                    ? document.exitFullscreen?.()
                    : document.documentElement.requestFullscreen?.();
            }

            toggleTheme() {
                const newTheme = this.theme === 'dark' ? 'light' : 'dark';
                this.setTheme(newTheme);
            }

            about() {
                window.open('https://github.com/vsakkas/shiro', '_blank');
            }
        }

        // Start Shiro
        new Shiro();
    </script>
</body>
</html>
